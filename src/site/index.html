<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="color-scheme" content="light dark">
        <title>Mojibake</title>
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <link rel="stylesheet" type="text/css" href="style.css">
        <style>
            .code {
                line-height: 1.5;
                border: 1px solid var(--border);
                padding: 1rem;
            }

            .function-call {
                cursor: pointer;
            }

            .function-call:hover {
                border-color: var(--border-hover);
            }

            .function-card {
                display: none;
            }

            #functions .selected .function-card {
                display: block;
            }

            .function-results {
                margin-top: 1rem;
                display: none;
            }

            .loading {
                display: none;
            }

            #loading {
                text-align: center;
            }

            .function-form label {
                text-transform: capitalize;
            }

            .function-form div, .function-form-button {
                margin-top: 1rem;
            }
        </style>
</head>
<body>
    <!-- Use at your own discretion, and feel free to collaborate. https://github.com/zaerl/mojibake/ -->
    <script type="module">
        window.mojibake = null;

        // Load the WASM module
        import('./mojibake.js').then(async (Module) => {
            window.mojibake = await Module.default();
            console.log('Mojibake WASM module loaded. Version:', window.mojibake.ccall('mjb_version', 'string'));
            document.getElementById('loading').remove();
            document.getElementById('functions').classList.remove('loading');

            const dbResponse = await fetch('mojibake.db');
            const dbArrayBuffer = await dbResponse.arrayBuffer();
            const dbBytes = new Uint8Array(dbArrayBuffer);
            const dbPtr = window.mojibake._malloc(dbBytes.length);
            window.mojibake.HEAPU8.set(dbBytes, dbPtr);

            let initialized = window.mojibake.ccall('mjb_initialize_v2', 'boolean',
                ['number', 'number', 'number', 'number', 'number'], [0, 0, 0, dbPtr, dbBytes.length]);
        }).catch(err => {
            console.error('Failed to load WASM module:', err);
        });
    </script>
    <div id="main" class="container">
        <section>
            <strong title="文字化け">Mojibake</strong> is a low-level Unicode 17 library written in C11.
            This is an online demo of the library, compiled to WebAssembly.
        </section>
        <section id="loading">
            <progress></progress>
        </section>
        <section id="functions" class="loading"></section>
    </div>
    <script>
        function codepointToString(codepoint, all = true) {
            if(!all && codepoint === 0) {
                return 'N/A';
            }

            return 'U+' + codepoint.toString(16).toUpperCase().padStart(4, '0');
        }

        // Used for mjb_next_character callback.
        function _mjbNextCharacterCallback(character, type) {
            const char = pointerToCharacter(character);

            const funcResults = document.getElementById('mjb_next_character-results');
            funcResults.style.display = 'block';
            let position = 'First';

            // See mjb_next_character_type on mojibake.h
            if(type & 0x1) {
                if(type & 0x2) {
                    position = '<strong>First and last</strong>: ';
                } else {
                    position = '<strong>First</strong>: ';
                }

                funcResults.innerHTML = '';
            } else if (type & 0x2) {
                position = '<br><strong>Last</strong>: ';
            } else {
                position = '<br>';
            }

            funcResults.innerHTML += `${position} ${codepointToString(char.codepoint)} <span class="text-primary">${char.name}</span>`;

            return true;
        }

        function pointerToCharacter(ptr) {
            const struct = new CStruct(ptr);

            const char = struct.toObject({
                codepoint: 'u32',
                name: 'str128',
                category: 'u32',
                combining: 'u32',
                bidirectional: 'u16',
                decomposition: 'u32',
                decimal: 'i32',
                digit: 'i32',
                numeric: 'str16',
                mirrored: 'u8',
                uppercase: 'u32',
                lowercase: 'u32',
                titlecase: 'u32',
            });

            if(char.decimal === -1) {
                char.decimal = null;
            }

            if(char.digit === -1) {
                char.digit = null;
            }

            return char;
        }

        class CStruct {
            #ptr;
            #offset = 0;

            constructor(ptr) {
                this.#ptr = ptr;
                this.#offset = 0;
            }

            u8() {
                const ret = window.window.mojibake.HEAPU8[this.#ptr + this.#offset];
                this.#offset += 1;
                return ret;
            }

            u16() {
                // Ensure 2-byte alignment
                this.#offset = Math.ceil(this.#offset / 2) * 2;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getUint16(0, true);
                this.#offset += 2;
                return ret;
            }

            u32() {
                // Ensure 4-byte alignment
                this.#offset = Math.ceil(this.#offset / 4) * 4;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getUint32(0, true);
                this.#offset += 4;
                return ret;
            }

            i32() {
                // Ensure 4-byte alignment
                this.#offset = Math.ceil(this.#offset / 4) * 4;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getInt32(0, true);
                this.#offset += 4;
                return ret;
            }

            str(max) {
                const nameBytes = new Uint8Array(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset, max);
                let end = nameBytes.indexOf(0);

                if(end === -1) {
                    end = max;
                }

                this.#offset += max;

                return new TextDecoder().decode(nameBytes.subarray(0, end));
            }

            toObject(signature) {
                const object = {};

                for(const name in signature) {
                    if(signature[name].startsWith('str')) {
                        object[name] = this.str(Number(signature[name].split('str')[1]));
                    } else {
                        object[name] = this[signature[name]]();
                    }
                }

                return object;
            }
        }

        // This is used for auto-generated site, do not edit this object.
        const functions = {};

        // C: mjb_category
        const categories = [
            'Letter, uppercase',
            'Letter, lowercase',
            'Letter, titlecase',
            'Letter, modifier',
            'Letter, other',
            'Mark, non-spacing',
            'Mark, spacing combining',
            'Mark, enclosing',
            'Number, decimal digit',
            'Number, letter',
            'Number, other',
            'Punctuation, connector',
            'Punctuation, dash',
            'Punctuation, open',
            'Punctuation, close',
            'Punctuation, initial quote',
            'Punctuation, final quote',
            'Punctuation, other',
            'Symbol, math',
            'Symbol, currency',
            'Symbol, modifier',
            'Symbol, other',
            'Separator, space',
            'Separator, line',
            'Separator, paragraph',
            'Other, control',
            'Other, format',
            'Other, surrogate',
            'Other, private use',
            'Other, not assigned',
        ];

        function ccallCodepointCharacter(codepoint) {
            // Allocate memory for mjb_character structure
            const structSize = 512;
            const ptr = window.mojibake._malloc(structSize);

            // Initialize memory to zero
            for(let i = 0; i < structSize; ++i) {
                window.mojibake.HEAPU8[ptr + i] = 0;
            }

            // Call mjb_codepoint_character
            const result = window.mojibake.ccall('mjb_codepoint_character', 'boolean',
                ['number', 'number'], [codepoint, ptr]);

            if(result) {
                const char = pointerToCharacter(ptr);

                let ret = `Codepoint <strong>${codepointToString(char.codepoint)}</strong>:<br>`;
                ret += `Name: <span class="text-primary">${char.name}</span><br>`;
                ret += `Category: <strong>${categories[char.category]}</strong><br>`;
                ret += `Combining: <strong>${char.combining}</strong><br>`;
                ret += `Bidirectional: <strong>${char.bidirectional}</strong><br>`;
                ret += `Decimal: <strong>${char.decimal === null ? 'N/A' : char.decimal}</strong><br>`;
                ret += `Digit: <strong>${char.digit === null ? 'N/A' : char.digit}</strong><br>`;
                ret += `Numeric: <strong>${char.numeric === '' ? 'N/A' : char.numeric}</strong><br>`;
                ret += `Mirrored: <strong>${char.mirrored ? 'true' : 'false'}</strong><br>`;
                ret += `Uppercase: <strong>${codepointToString(char.uppercase, false)}</strong><br>`;
                ret += `Lowercase: <strong>${codepointToString(char.lowercase, false)}</strong><br>`;
                ret += `Titlecase: <strong>${codepointToString(char.titlecase, false)}</strong>`;

                return ret;
            } else {
                console.log(`Failed to get character data for ${codepointToString(codepoint)}`);
            }

            // Free allocated memory
            window.mojibake._free(ptr);

            return false;
        }

        function stringToCodepointList(string) {
            const codepoints = [];

            for (let i = 0; i < string.length; i++) {
                const codepoint = string.codePointAt(i);

                if(codepoint) {
                    codepoints.push(codepointToString(codepoint));

                    // Skip the second surrogate pair code unit
                    if (codepoint > 0xFFFF) {
                        i++;
                    }
                }
            }

            return codepoints;
        }

        function utf8StringToHex(ptr, length) {
            const heap = window.mojibake.HEAPU8;
            const hex = [];
            let i = 0;

            while(heap[ptr] !== 0 || (i < length)) {
                hex.push(heap[ptr].toString(16).toUpperCase().padStart(2, '0'));
                ++ptr;
                ++i;
            }

            return hex;
        }

        function ccallNormalize(buffer, size, encoding, form) {
            // See mjb_result on mojibake.h
            const structSize = 24;
            const ptr = window.mojibake._malloc(structSize);

            // Initialize memory to zero
            for(let i = 0; i < structSize; ++i) {
                window.mojibake.HEAPU8[ptr + i] = 0;
            }

            // Call mjb_codepoint_character
            const result = window.mojibake.ccall('mjb_normalize', 'boolean',
                ['string', 'number', 'number', 'number', 'number'],
                [buffer, size, encoding, form, ptr]);

            if(result) {
                const struct = new CStruct(ptr);
                const result = struct.toObject({
                    output: 'u32',
                    output_size: 'u32',
                    normalized: 'u8'
                });

                const output = window.mojibake.UTF8ToString(result.output);
                let ret = `Output: <strong>${output}</strong><br>`;
                ret += `Hex UTF-8: <strong>${utf8StringToHex(result.output, result.output_size).join(' ')}</strong><br>`;
                ret += `Output: <strong>${stringToCodepointList(output).join(' ')}</strong><br>`;
                ret += `Output size: <strong>${result.output_size}</strong><br>`;
                ret += `Has been normalized: <strong>${result.transformed ? 'true' : 'false'}</strong><br>`;

                return ret;
            } else {
                console.log('Failed to get normalization data');
            }

            // Free allocated memory
            window.mojibake._free(ptr);

            return false;
        }

        function toggleFunctionCall(func) {
            const funcDiv = document.getElementById(func);
            const selected = funcDiv.classList.toggle('selected');

            if(!selected) {
                const form = document.getElementById(func + '-form');

                if(form) {
                    form.reset();
                }
            }
        }

        function ccCall(func, ret, argTypes, args) {
            if(func === 'mjb_codepoint_character') {
                return ccallCodepointCharacter(args[0]);
            } else if(func === 'mjb_normalize') {
                return ccallNormalize(args[0], args[1], args[2], args[3]);
            } else {
                console.log(func, ret, argTypes, args);
                return window.mojibake.ccall(func, ret, argTypes, args);
            }
        }

        function callFunction(func) {
            const funcDiv = document.getElementById(func);
            const form = document.getElementById(func + '-form');
            const funcResults = document.getElementById(func + '-results');

            if(functions[func].args.length === 1 && functions[func].args[0] === 'void') {
                const result = window.mojibake.ccall(func, functions[func].ret === 'const char *' ? 'string' : 'number', []);
                funcResults.innerHTML = result;

                return;
            }

            function typeMap(type) {
                if(type === 'const char *') {
                    return 'string';
                } else if(type === 'char *') {
                    return 'string';
                } else if(type === 'bool') {
                    return 'boolean';
                }

                return 'number';
            }

            function readCodepoint(value) {
                // Handle different codepoint formats: decimal, hex, 0x hex, U+FFFF
                value = value.trim().toUpperCase();

                if (value.startsWith('U+')) {
                    // U+FFFF format
                    return parseInt(value.substring(2), 16);
                } else if (value.startsWith('0X')) {
                    // 0xFFFF format
                    return parseInt(value.substring(2), 16);
                } else {
                    // Plain hex format
                    return parseInt(value, 16);
                }
            }

            let i = 0;
            const args = [];
            const argTypes = [];
            const ret = typeMap(functions[func].ret);
            let hasBuffer = null;

            for(const arg of functions[func].args) {
                const mappedType = typeMap(functions[func].argsTypes[i]);
                let value = null;

                argTypes.push(mappedType);

                if(functions[func].wasmGenerated[i]) {
                    if(functions[func].argsTypes[i] === 'size_t' && (arg === 'size' || arg === 'max_length')
                        && hasBuffer !== null) {
                        // Calculate the size of the buffer in bytes (UTF-8)
                        const encoder = new TextEncoder().encode(hasBuffer);
                        value = encoder.length;
                    }
                } else {
                    value = form.elements[`${func}-${arg}`].value;

                    if(functions[func].argsTypes[i] === 'mjb_codepoint') {
                        value = readCodepoint(value);
                    } else if(mappedType === 'number') {
                        value = parseInt(value, 10);
                    } else if(mappedType === 'boolean') {
                        value = form.elements[`${func}-${arg}`].checked;
                    }

                    if(hasBuffer === null && functions[func].argsTypes[i] === 'const char *' && arg === 'buffer') {
                        hasBuffer = value;
                    }
                }

                args.push(value);

                ++i;
            }

            let result = ccCall(func, ret, argTypes, args);

            if(functions[func].ret === 'mjb_codepoint') {
                result = codepointToString(result);
            }

            funcResults.style.display = 'block';

            if(func === 'mjb_next_character') {
                return;
            }

            funcResults.innerHTML = result;
        }
    </script>
</body>
</html>
