<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <title>Mojibake, Unicode 17 library written in C11</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <div id="main" class="container">
        <h1 title="文字化け">Mojibake</h1>
        <section>
            <strong>Mojibake</strong> is a low-level Unicode 17 library written in C11. It can be compiled as C++17 as well.
            Mojibake (Japanese: 文字化け 'character transformation') is the garbled text that is the result
            of text being decoded using an unintended character encoding. I created this library because I don't
            like any of the existing one.
        </section>
        <section>
            The <a href="https://github.com/zaerl/mojibake" target="_blank">source code</a> is released under the MIT License.
            It consists in a <strong>mojibake.c</strong> file, a <strong>mojibake.h</strong> file and a <strong>mojibake.db</strong> file.
            A <strong>shell.c</strong> file is also provided that let you build a <strong>mojibake</strong> CLI, if you want. Also a
            C++ wrapper can be found on <strong>ext/cpp/mojibake.cpp</strong> if you prefer it.
        </section>
        <section>
            The <strong>mojibake.c/.h</strong> files are an amalgamation of all the source files. And are the only files you need to include
            in your project. The <strong>mojibake.db</strong> file is a SQLite database file that contains all the data from the Unicode
            Character Database.
        </section>
        <section>An alternative embedded version is provided, where the <strong>mojibake.db</strong> file is not needed, and only
            the <strong>mojibake.c</strong> and <strong>mojibake.h</strong> are needed. The content of the database is loaded directly from
            the C file.
        </section>
        <section>
            <a href="[AM_HREF]" target="_blank">[AM_NAME]</a>, version <strong>[VERSION]</strong>. Amalgamation of mojibake.c, mojibake.h and mojibake.db.
        </section>
        <section>
            <a href="[EMBEDDED_HREF]" target="_blank">[EMBEDDED_NAME]</a>, version <strong>[VERSION]</strong>. Amalgamation of mojibake.c with embedded database and mojibake.h.
        </section>
        <section>
            <a href="[WASM_HREF]" target="_blank">[WASM_NAME]</a>, version <strong>[VERSION]</strong>. Precompiled WASM version of mojibake.js, mojibake.wasm and mojibake.db.
        </section>
        <section>
            <h2>Try it online</h2>
            <p>
                You can try the library online by using the WASM-compiled version. It is a live demo that
                you can use to preview the API.
            </p>
        </section>
        <section id="functions"></section>
    </div>
    <!-- Use at your own discretion, and feel free to collaborate. https://github.com/zaerl/mojibake/ -->
    <script>
        // This is used for auto-generated site, do not edit this object.
        const functions = {};

        // C: mjb_category
        const categories = [
            'Letter, uppercase',
            'Letter, lowercase',
            'Letter, titlecase',
            'Letter, modifier',
            'Letter, other',
            'Mark, non-spacing',
            'Mark, spacing combining',
            'Mark, enclosing',
            'Number, decimal digit',
            'Number, letter',
            'Number, other',
            'Punctuation, connector',
            'Punctuation, dash',
            'Punctuation, open',
            'Punctuation, close',
            'Punctuation, initial quote',
            'Punctuation, final quote',
            'Punctuation, other',
            'Symbol, math',
            'Symbol, currency',
            'Symbol, modifier',
            'Symbol, other',
            'Separator, space',
            'Separator, line',
            'Separator, paragraph',
            'Other, control',
            'Other, format',
            'Other, surrogate',
            'Other, private use',
            'Other, not assigned',
        ];

        function typeMap(type) {
            if(type === 'const char *') {
                return 'string';
            } else if(type === 'char *') {
                return 'string';
            } else if(type === 'bool') {
                return 'boolean';
            }
            return 'number';
        }

        function codepointToString(codepoint, all = true) {
            if(!all && (codepoint === 0 || codepoint === null)) {
                return 'N/A';
            }

            return 'U+' + codepoint.toString(16).toUpperCase().padStart(4, '0');
        }

        function encodingToString(encoding, includeHex = false) {
            const encodings = {
                0x0: 'Unknown',
                0x1: 'ASCII',
                0x2: 'UTF-8',
                0x4: 'UTF-16',
                0x8: 'UTF-16BE',
                0x10: 'UTF-16LE',
                0x20: 'UTF-32',
                0x40: 'UTF-32BE',
                0x80: 'UTF-32LE',
            };

            let ret = [];

            for(const key in encodings) {
                if(encoding & key) {
                    ret.push(encodings[key] + (includeHex ? ' (0x' + key.toString(16).toUpperCase() + ')' : ''));
                }
            }

            return ret.join(', ');
        }

        function toggleFunctionCall(func) {
            const funcDiv = document.getElementById(func);
            const selected = funcDiv.classList.toggle('selected');

            if(!selected) {
                const form = document.getElementById(func + '-form');

                if(form) {
                    form.reset();
                }
            }
        }

        async function callAPI(args) {
            const params = new URLSearchParams(args);
            const result = await fetch('[API_URL]?' + params.toString());

            return await result.json();
        }

        function parseCodepointCharacter(char) {
            let ret = `Codepoint <strong>${codepointToString(char.codepoint)}</strong>:<br>`;
            ret += `Name: <span class="text-primary">${char.name}</span><br>`;
            ret += `Category: <strong>${categories[char.category]}</strong><br>`;
            ret += `Combining: <strong>${char.combining}</strong><br>`;
            ret += `Bidirectional: <strong>${char.bidirectional}</strong><br>`;
            ret += `Decimal: <strong>${char.decimal === null ? 'N/A' : char.decimal}</strong><br>`;
            ret += `Digit: <strong>${char.digit === null ? 'N/A' : char.digit}</strong><br>`;
            ret += `Numeric: <strong>${char.numeric === '' ? 'N/A' : char.numeric}</strong><br>`;
            ret += `Mirrored: <strong>${char.mirrored ? 'true' : 'false'}</strong><br>`;
            ret += `Uppercase: <strong>${codepointToString(char.uppercase, false)}</strong><br>`;
            ret += `Lowercase: <strong>${codepointToString(char.lowercase, false)}</strong><br>`;
            ret += `Titlecase: <strong>${codepointToString(char.titlecase, false)}</strong>`;

            return ret;
        }

        function parseNormalize(result) {
            let ret = `Output: <strong>${result.output}</strong><br>`;
            ret += `Hex UTF-8: <strong>${result.utf8}</strong><br>`;
            ret += `Codepoints: <strong>${result.codepoints}</strong><br>`;
            ret += `Output size: <strong>${result.output_size}</strong><br>`;
            ret += `Has been normalized: <strong>${result.transformed ? 'true' : 'false'}</strong><br>`;

            return ret;
        }

        function parseEmoji(result) {
            let ret = `Codepoint <strong>${codepointToString(result.codepoint)}</strong>:<br>`;
            ret += `Emoji: <strong>${result.emoji ? 'true' : 'false'}</strong><br>`;
            ret += `Presentation: <strong>${result.presentation ? 'true' : 'false'}</strong><br>`;
            ret += `Modifier: <strong>${result.modifier ? 'true' : 'false'}</strong><br>`;
            ret += `Modifier Base: <strong>${result.modifier_base ? 'true' : 'false'}</strong><br>`;
            ret += `Component: <strong>${result.component ? 'true' : 'false'}</strong><br>`;
            ret += `Extended Pictographic: <strong>${result.extended_pictographic ? 'true' : 'false'}</strong><br>`;

            return ret;
        }

        function parseNextCharacter(result) {
            let ret = '';

            // Use an index and add a <br> if it's not the last one
            for(let i = 0; i < result.characters.length; ++i) {
                ret += parseCodepointCharacter(result.characters[i]);

                if(i !== result.characters.length - 1) {
                    ret += '<br><br>';
                }
            }

            return ret;
        }

        async function callFunction(func) {
            const funcDiv = document.getElementById(func);
            const form = document.getElementById(func + '-form');
            const funcResults = document.getElementById(func + '-results');
            console.log(func, functions[func].args);

            if(functions[func].args.length === 0 ||
                (functions[func].args.length === 1 && functions[func].args[0].type === 'void')) {
                const data = await callAPI({ 'function': func });

                if(data.error) {
                    funcResults.innerHTML = data.message;
                } else {
                    funcResults.innerHTML = data[func.replace(/^mjb_/, '')];
                }

                funcResults.style.display = 'block';

                return;
            }

            let i = 0;
            let args = { 'function': func };

            for(const arg of functions[func].args) {
                if(arg.wasm_generated) {
                    continue;
                }

                console.log(`${func}-${arg.name}`);
                console.log(form.elements[`${func}-${arg.name}`]);
                value = form.elements[`${func}-${arg.name}`].value;

                if(arg.type === 'bool') {
                    value = form.elements[`${func}-${arg.name}`].checked;
                } else if(arg.type === 'mjb_encoding') {
                    value = encodingToString(value);
                }

                args[arg.name] = value;
                ++i;
            }

            let data = await callAPI(args);

            if(data.error) {
                funcResults.innerHTML = data.message;
                funcResults.style.display = 'block';

                return;
            }

            if(func === 'mjb_codepoint_character') {
                data = parseCodepointCharacter(data);
            } else if(func === 'mjb_normalize') {
                data = parseNormalize(data);
            } else if(func === 'mjb_codepoint_emoji') {
                data = parseEmoji(data);
            } else if(func === 'mjb_next_character') {
                data = parseNextCharacter(data);
            }

            if(functions[func].ret === 'mjb_codepoint') {
                result = codepointToString(result);
            } else if(functions[func].ret === 'mjb_encoding') {
                result = encodingToString(result, true);
            }

            funcResults.innerHTML = data;
            funcResults.style.display = 'block';
        }

        const urlParams = new URLSearchParams(window.location.search);
        const functionParam = urlParams.get('function');

        // Use the function parameter if provided
        if(functionParam && functions[functionParam]) {
            const targetDiv = document.getElementById(functionParam);
            const form = document.getElementById(functionParam + '-form');
            let ready = true;

            if(form) {
                form.reset();
            }

            for(let i = 0; i < functions[functionParam].args.length; ++i) {
                let arg = functions[functionParam].args[i];
                if(arg.wasm_generated) {
                    continue;
                }

                const param = urlParams.get(arg.name);

                if(param === null) {
                    ready = false;
                    break;
                }

                const input = document.getElementById(functionParam + '-' + arg.name);

                if(input) {
                    input.value = param;
                }
            }

            targetDiv.scrollIntoView({ block: 'start' });
            toggleFunctionCall(functionParam);

            if(ready) {
                callFunction(functionParam);
            }
        }
    </script>
</body>
</html>
