<!DOCTYPE html>
<html lang="en" data-theme="dark">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="color-scheme" content="light dark">
        <title>Mojibake</title>
        <link rel="stylesheet" type="text/css" href="chota.css">
        <style>
            body.dark {
                --bg-color: #000;
                --bg-secondary-color: #262626;
                --font-color: #f5f5f5;
                --color-grey: #bbb;
                --color-darkGrey: #888;
                --color-primary: #17c16f;
                --color-error: #ea4f4f;
            }

            body > .container {
                max-width: 720px;
            }

            section {
                margin: 2rem auto;
            }

            code {
                color: var(--font-color);
                display: inline-block;
                padding: 1rem;
                cursor: pointer;
            }

            .function-card {
                margin-top: 1rem;
                border-radius: 4px;
                display: none;
                padding: 1rem;
            }

            #functions .selected .function-card {
                display: block;
            }

            .function-form label {
                text-transform: capitalize;
            }

            .function-results {
                margin-top: 1rem;
                display: none;
            }

            .loading {
                display: none;
            }
        </style>
</head>
<body>
    <!-- Use at your own discretion, and feel free to collaborate. https://github.com/zaerl/mojibake/ -->
    <script type="module">
        window.mojibake = null;

        // Load the WASM module
        import('./mojibake.js').then(async (Module) => {
            window.mojibake = await Module.default();
            console.log('Mojibake WASM module loaded. Version:', window.mojibake.ccall('mjb_version', 'string'));
            document.getElementById('loading').remove();
            document.getElementById('functions').classList.remove('loading');

            const dbResponse = await fetch('mojibake.db');
            const dbArrayBuffer = await dbResponse.arrayBuffer();
            const dbBytes = new Uint8Array(dbArrayBuffer);
            const dbPtr = window.mojibake._malloc(dbBytes.length);
            window.mojibake.HEAPU8.set(dbBytes, dbPtr);

            let initialized = window.mojibake.ccall('mjb_initialize_v2', 'boolean',
                ['number', 'number', 'number', 'number', 'number'], [0, 0, 0, dbPtr, dbBytes.length]);
        }).catch(err => {
            console.error('Failed to load WASM module:', err);
        });
    </script>
    <div id="main" class="container">
        <section id="header">
            <nav class="nav">
                <div class="nav-left">
                  <a href="https://github.com/zaerl/mojibake">Github</a>
                </div>
                <div class="nav-center">
                  <a id="title" class="brand" title="ÊñáÂ≠óÂåñ„Åë">Mojibake</a>
                </div>
                <div class="nav-right">
                    <a href="javascript:void(0)" id="theme-switch" onclick="switchMode(this)">‚òÄÔ∏è</a>
                </div>
            </nav>
        </section>
        <section>
            <strong>Mojibake</strong> is a low-level Unicode 16 library written in C99. This is an
            online demo of the library, compiled to WebAssembly.</section>
        <section id="loading" class="is-horizontal-align">
            <progress></progress>
        </section>
        <section id="functions" class="loading"></section>
    </div>
    <script>
        if(
            window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
        ) {
            document.body.classList.add("dark");
            document.querySelector('#theme-switch').innerHTML = "üåô"
        }

        function codepointToString(codepoint) {
            return 'U+' + codepoint.toString(16).toUpperCase().padStart(4, '0');
        }

        class CStruct {
            #ptr;
            #offset = 0;

            constructor(ptr) {
                this.#ptr = ptr;
                this.#offset = 0;
            }

            u8() {
                const ret = window.window.mojibake.HEAPU8[this.#ptr + this.#offset];
                this.#offset += 1;
                return ret;
            }

            u16() {
                // Ensure 2-byte alignment
                this.#offset = Math.ceil(this.#offset / 2) * 2;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getUint16(0, true);
                this.#offset += 2;
                return ret;
            }

            u32() {
                // Ensure 4-byte alignment
                this.#offset = Math.ceil(this.#offset / 4) * 4;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getUint32(0, true);
                this.#offset += 4;
                return ret;
            }

            i32() {
                // Ensure 4-byte alignment
                this.#offset = Math.ceil(this.#offset / 4) * 4;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getInt32(0, true);
                this.#offset += 4;
                return ret;
            }

            str(max) {
                const nameBytes = new Uint8Array(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset, max);
                let end = nameBytes.indexOf(0);

                if(end === -1) {
                    end = max;
                }

                this.#offset += max;

                return new TextDecoder().decode(nameBytes.subarray(0, end));
            }

            toObject(signature) {
                const object = {};

                for(const name in signature) {
                    if(signature[name].startsWith('str')) {
                        object[name] = this.str(Number(signature[name].split('str')[1]));
                    } else {
                        object[name] = this[signature[name]]();
                    }
                }

                return object;
            }
        }

        function switchMode(el) {
            const bodyClass = document.body.classList;
            bodyClass.contains("dark")
                ? ((el.innerHTML = "‚òÄÔ∏è"), bodyClass.remove("dark"))
                : ((el.innerHTML = "üåô"), bodyClass.add("dark"));
        }

        // This is used for auto-generated site, do not edit this object.
        const functions = {};

        function ccallCodepointCharacter(codepoint) {
            // Allocate memory for mjb_character structure
            const structSize = 512;
            const ptr = window.mojibake._malloc(structSize);

            // Initialize memory to zero
            for(let i = 0; i < structSize; i++) {
                window.mojibake.HEAPU8[ptr + i] = 0;
            }

            // Call mjb_codepoint_character
            const result = window.mojibake.ccall('mjb_codepoint_character', 'boolean',
                ['number', 'number'], [codepoint, ptr]);

            if(result) {
                const struct = new CStruct(ptr);
                const char = struct.toObject({
                    codepoint: 'u32',
                    name: 'str128',
                    category: 'u32',
                    combining: 'u32',
                    bidirectional: 'u16',
                    decomposition: 'u32',
                    decimal: 'i32',
                    digit: 'i32',
                    numeric: 'str16',
                    mirrored: 'u8',
                    uppercase: 'u32',
                    lowercase: 'u32',
                    titlecase: 'u32',
                });

                if(char.decimal === -1) {
                    char.decimal = null;
                }

                if(char.digit === -1) {
                    char.digit = null;
                }

                let ret = `Character <strong>${codepointToString(char.codepoint)}</strong>:<br>`;
                ret += `Name: <strong>${char.name}</strong><br>`;
                ret += `Category: <strong>${char.category}</strong><br>`;
                ret += `Combining Class: <strong>${char.combining}</strong><br>`;
                ret += `Bidirectional: <strong>${char.bidirectional}</strong><br>`;
                ret += `Decimal: <strong>${char.decimal}</strong><br>`;
                ret += `Digit: <strong>${char.digit}</strong><br>`;
                ret += `Numeric: <strong>${char.numeric}</strong><br>`;
                ret += `Mirrored: <strong>${char.mirrored ? 'true' : 'false'}</strong><br>`;
                ret += `Uppercase: <strong>${codepointToString(char.uppercase)}</strong><br>`;
                ret += `Lowercase: <strong>${codepointToString(char.lowercase)}</strong><br>`;
                ret += `Titlecase: <strong>${codepointToString(char.titlecase)}</strong>`;

                return ret;
            } else {
                console.log(`Failed to get character data for ${codepointToString(codepoint)}`);
            }

            // Free allocated memory
            window.mojibake._free(ptr);

            return false;
        }

        function toggleFunctionCall(func) {
            const funcDiv = document.getElementById(func);
            const selected = funcDiv.classList.toggle('selected');

            if(!selected) {
                const form = document.getElementById(func + '-form');

                if(form) {
                    form.reset();
                }
            }
        }

        function ccCall(func, ret, argTypes, args) {
            console.log(func, ret);
            console.log(argTypes, args);

            if(func === 'mjb_codepoint_character') {
                return ccallCodepointCharacter(args[0]);
            } else {
                return window.mojibake.ccall(func, ret, argTypes, args);
            }
        }

        function callFunction(func) {
            const funcDiv = document.getElementById(func);
            const form = document.getElementById(func + '-form');
            const funcResults = document.getElementById(func + '-results');

            if(functions[func].args.length === 1 && functions[func].args[0] === 'void') {
                const result = window.mojibake.ccall(func, functions[func].ret === 'const char *' ? 'string' : 'number', []);
                funcResults.innerHTML = result;

                return;
            }

            function typeMap(type) {
                if(type === 'const char *') {
                    return 'string';
                } else if(type === 'bool') {
                    return 'boolean';
                }

                return 'number';
            }

            function readCodepoint(value) {
                // Handle different codepoint formats: decimal, hex, 0x hex, U+FFFF
                value = value.trim().toUpperCase();

                if (value.startsWith('U+')) {
                    // U+FFFF format
                    return parseInt(value.substring(2), 16);
                } else if (value.startsWith('0X')) {
                    // 0xFFFF format
                    return parseInt(value.substring(2), 16);
                } else if (/^[0-9A-F]+$/.test(value)) {
                    // Plain hex format
                    return parseInt(value, 16);
                } else {
                    // Decimal format
                    return parseInt(value, 10);
                }
            }

            let i = 0;
            const args = [];
            const argTypes = [];
            const ret = typeMap(functions[func].ret);

            for(const arg of functions[func].args) {
                const mappedType = typeMap(functions[func].argsTypes[i]);
                argTypes.push(mappedType);

                if(!functions[func].argsReturn[i]) {
                    let value = form.elements[`${func}-${arg}`].value;

                    if(functions[func].argsTypes[i] === 'mjb_codepoint') {
                        value = readCodepoint(value);
                    } else if(mappedType === 'number') {
                        value = parseInt(value, 10);
                    }

                    args.push(value);
                }

                ++i;
            }

            let result = ccCall(func, ret, argTypes, args);

            if(functions[func].ret === 'mjb_codepoint') {
                result = codepointToString(result);
            }

            funcResults.style.display = 'block';
            funcResults.innerHTML = result;
        }
    </script>
</body>
</html>
