<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="color-scheme" content="light dark">
        <title>Mojibake</title>
        <!--<link rel="stylesheet" type="text/css" href="chota.css">-->
        <link rel="stylesheet" type="text/css" href="style.css">
        <style>
            .code {
                line-height: 1.5;
                border: 1px solid var(--border);
                padding: 1rem;
            }

            .function-call {
                cursor: pointer;
            }

            .function-call:hover {
                border-color: var(--border-hover);
            }

            .function-card {
                display: none;
            }

            #functions .selected .function-card {
                display: block;
            }

            .function-results {
                margin-top: 1rem;
                display: none;
            }

            .loading {
                display: none;
            }

            #loading {
                text-align: center;
            }

            .function-form label {
                text-transform: capitalize;
            }

            .function-form div, .function-form-button {
                margin-top: 1rem;
            }
        </style>
</head>
<body>
    <!-- Use at your own discretion, and feel free to collaborate. https://github.com/zaerl/mojibake/ -->
    <script type="module">
        window.mojibake = null;

        // Load the WASM module
        import('./mojibake.js').then(async (Module) => {
            window.mojibake = await Module.default();
            console.log('Mojibake WASM module loaded. Version:', window.mojibake.ccall('mjb_version', 'string'));
            document.getElementById('loading').remove();
            document.getElementById('functions').classList.remove('loading');

            const dbResponse = await fetch('mojibake.db');
            const dbArrayBuffer = await dbResponse.arrayBuffer();
            const dbBytes = new Uint8Array(dbArrayBuffer);
            const dbPtr = window.mojibake._malloc(dbBytes.length);
            window.mojibake.HEAPU8.set(dbBytes, dbPtr);

            let initialized = window.mojibake.ccall('mjb_initialize_v2', 'boolean',
                ['number', 'number', 'number', 'number', 'number'], [0, 0, 0, dbPtr, dbBytes.length]);
        }).catch(err => {
            console.error('Failed to load WASM module:', err);
        });
    </script>
    <div id="main" class="container">
        <section>
            <strong title="文字化け">Mojibake</strong> is a low-level Unicode 16 library written in C99. This is an
            online demo of the library, compiled to WebAssembly.
        </section>
        <section id="loading">
            <progress></progress>
        </section>
        <section id="functions" class="loading"></section>
    </div>
    <script>
        function codepointToString(codepoint, all = true) {
            if(!all && codepoint === 0) {
                return 'N/A';
            }

            return 'U+' + codepoint.toString(16).toUpperCase().padStart(4, '0');
        }

        class CStruct {
            #ptr;
            #offset = 0;

            constructor(ptr) {
                this.#ptr = ptr;
                this.#offset = 0;
            }

            u8() {
                const ret = window.window.mojibake.HEAPU8[this.#ptr + this.#offset];
                this.#offset += 1;
                return ret;
            }

            u16() {
                // Ensure 2-byte alignment
                this.#offset = Math.ceil(this.#offset / 2) * 2;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getUint16(0, true);
                this.#offset += 2;
                return ret;
            }

            u32() {
                // Ensure 4-byte alignment
                this.#offset = Math.ceil(this.#offset / 4) * 4;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getUint32(0, true);
                this.#offset += 4;
                return ret;
            }

            i32() {
                // Ensure 4-byte alignment
                this.#offset = Math.ceil(this.#offset / 4) * 4;
                const ret = new DataView(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset).getInt32(0, true);
                this.#offset += 4;
                return ret;
            }

            str(max) {
                const nameBytes = new Uint8Array(window.mojibake.HEAPU8.buffer, this.#ptr + this.#offset, max);
                let end = nameBytes.indexOf(0);

                if(end === -1) {
                    end = max;
                }

                this.#offset += max;

                return new TextDecoder().decode(nameBytes.subarray(0, end));
            }

            toObject(signature) {
                const object = {};

                for(const name in signature) {
                    if(signature[name].startsWith('str')) {
                        object[name] = this.str(Number(signature[name].split('str')[1]));
                    } else {
                        object[name] = this[signature[name]]();
                    }
                }

                return object;
            }
        }

        // This is used for auto-generated site, do not edit this object.
        const functions = {};

        // C: mjb_category
        const categories = [
            'Letter, uppercase',
            'Letter, lowercase',
            'Letter, titlecase',
            'Letter, modifier',
            'Letter, other',
            'Mark, non-spacing',
            'Mark, spacing combining',
            'Mark, enclosing',
            'Number, decimal digit',
            'Number, letter',
            'Number, other',
            'Punctuation, connector',
            'Punctuation, dash',
            'Punctuation, open',
            'Punctuation, close',
            'Punctuation, initial quote',
            'Punctuation, final quote',
            'Punctuation, other',
            'Symbol, math',
            'Symbol, currency',
            'Symbol, modifier',
            'Symbol, other',
            'Separator, space',
            'Separator, line',
            'Separator, paragraph',
            'Other, control',
            'Other, format',
            'Other, surrogate',
            'Other, private use',
            'Other, not assigned',
        ];

        function ccallCodepointCharacter(codepoint) {
            // Allocate memory for mjb_character structure
            const structSize = 512;
            const ptr = window.mojibake._malloc(structSize);

            // Initialize memory to zero
            for(let i = 0; i < structSize; i++) {
                window.mojibake.HEAPU8[ptr + i] = 0;
            }

            // Call mjb_codepoint_character
            const result = window.mojibake.ccall('mjb_codepoint_character', 'boolean',
                ['number', 'number'], [codepoint, ptr]);

            if(result) {
                const struct = new CStruct(ptr);
                const char = struct.toObject({
                    codepoint: 'u32',
                    name: 'str128',
                    category: 'u32',
                    combining: 'u32',
                    bidirectional: 'u16',
                    decomposition: 'u32',
                    decimal: 'i32',
                    digit: 'i32',
                    numeric: 'str16',
                    mirrored: 'u8',
                    uppercase: 'u32',
                    lowercase: 'u32',
                    titlecase: 'u32',
                });

                if(char.decimal === -1) {
                    char.decimal = null;
                }

                if(char.digit === -1) {
                    char.digit = null;
                }

                let ret = `Character <strong>${codepointToString(char.codepoint)}</strong>:<br>`;
                ret += `Name: <span class="text-primary">${char.name}</span><br>`;
                ret += `Category: <strong>${categories[char.category]}</strong><br>`;
                ret += `Combining Class: <strong>${char.combining}</strong><br>`;
                ret += `Bidirectional: <strong>${char.bidirectional}</strong><br>`;
                ret += `Decimal: <strong>${char.decimal}</strong><br>`;
                ret += `Digit: <strong>${char.digit}</strong><br>`;
                ret += `Numeric: <strong>${char.numeric}</strong><br>`;
                ret += `Mirrored: <strong>${char.mirrored ? 'true' : 'false'}</strong><br>`;
                ret += `Uppercase: <strong>${codepointToString(char.uppercase, false)}</strong><br>`;
                ret += `Lowercase: <strong>${codepointToString(char.lowercase, false)}</strong><br>`;
                ret += `Titlecase: <strong>${codepointToString(char.titlecase, false)}</strong>`;

                return ret;
            } else {
                console.log(`Failed to get character data for ${codepointToString(codepoint)}`);
            }

            // Free allocated memory
            window.mojibake._free(ptr);

            return false;
        }

        function toggleFunctionCall(func) {
            const funcDiv = document.getElementById(func);
            const selected = funcDiv.classList.toggle('selected');

            if(!selected) {
                const form = document.getElementById(func + '-form');

                if(form) {
                    form.reset();
                }
            }
        }

        function ccCall(func, ret, argTypes, args) {
            console.log(func, ret);
            console.log(argTypes, args);

            if(func === 'mjb_codepoint_character') {
                return ccallCodepointCharacter(args[0]);
            } else {
                return window.mojibake.ccall(func, ret, argTypes, args);
            }
        }

        function callFunction(func) {
            const funcDiv = document.getElementById(func);
            const form = document.getElementById(func + '-form');
            const funcResults = document.getElementById(func + '-results');

            if(functions[func].args.length === 1 && functions[func].args[0] === 'void') {
                const result = window.mojibake.ccall(func, functions[func].ret === 'const char *' ? 'string' : 'number', []);
                funcResults.innerHTML = result;

                return;
            }

            function typeMap(type) {
                if(type === 'const char *') {
                    return 'string';
                } else if(type === 'bool') {
                    return 'boolean';
                }

                return 'number';
            }

            function readCodepoint(value) {
                // Handle different codepoint formats: decimal, hex, 0x hex, U+FFFF
                value = value.trim().toUpperCase();

                if (value.startsWith('U+')) {
                    // U+FFFF format
                    return parseInt(value.substring(2), 16);
                } else if (value.startsWith('0X')) {
                    // 0xFFFF format
                    return parseInt(value.substring(2), 16);
                } else {
                    // Plain hex format
                    return parseInt(value, 16);
                }
            }

            let i = 0;
            const args = [];
            const argTypes = [];
            const ret = typeMap(functions[func].ret);

            for(const arg of functions[func].args) {
                const mappedType = typeMap(functions[func].argsTypes[i]);
                argTypes.push(mappedType);

                if(!functions[func].argsReturn[i]) {
                    let value = form.elements[`${func}-${arg}`].value;

                    if(functions[func].argsTypes[i] === 'mjb_codepoint') {
                        value = readCodepoint(value);
                    } else if(mappedType === 'number') {
                        value = parseInt(value, 10);
                    }

                    args.push(value);
                }

                ++i;
            }

            let result = ccCall(func, ret, argTypes, args);

            if(functions[func].ret === 'mjb_codepoint') {
                result = codepointToString(result);
            }

            funcResults.style.display = 'block';
            funcResults.innerHTML = result;
        }
    </script>
</body>
</html>
