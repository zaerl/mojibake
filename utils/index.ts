import { writeFileSync, createReadStream } from 'fs';
import { createInterface } from 'readline';

interface Buffer {
  name: string;
  count: number;
}

interface Numeric {
  name: string;
  value: number;
  count: number;
}

function compareFn(a: Buffer, b: Buffer): number {
  const ret = b.count - a.count;

  if(ret === 0) {
    if(a.name < b.name) {
      return -1;
    } else if(a.name > b.name) {
      return 1;
    }

    return 0;
  }

  return ret;
}

function header(name: string): string {
  name = name.toUpperCase();

  return `${license()}

#ifndef UCX_${name}_H
#define UCX_${name}_H`;
}

function footer(name: string): string {
  name = name.toUpperCase();

  return `#endif /* UCX_${name}_H */`;
}

function license(): string {
  return `/**
 * The UCX library
 *
 * This file is distributed under the MIT License. See LICENSE for details.
 *
 * This code is autogenerated do not modify
 */`;
}

async function readUnicodeData() {
  const nameBuffer: { [name: string]: number } = {};
  const categoryBuffer: { [name: string]: number } = {};
  let charsCount = 0;
  let wordsCount = 0;
  let lines = 0;
  let entries: string[] = [];
  let hasNumber: { [name: string]: number } = {};

  const rl = createInterface({
    input: createReadStream('./UCD/UnicodeData.txt'),
    crlfDelay: Infinity
  });

  for await (const line of rl) {
    const split = line.split(';');
    const name = split[2] === 'Cc' && split[10] !== '' ? split[10] : split[1];
    const words = name.split(' ');

    ++lines;
    charsCount += name.length;
    wordsCount += words.length;

    if(split[8] !== '') {
      if(typeof(hasNumber[split[8]]) === 'undefined') {
        hasNumber[split[8]] = 1;
      } else {
        ++hasNumber[split[8]];
      }
    }

    entries.push(`    { 0x${split[0]}, UCX_GENERAL_CATEGORY_${split[2].toUpperCase()}, "${name}" }`);

    for(const word of words) {
      if(typeof(nameBuffer[word]) === 'undefined') {
        nameBuffer[word] = 1;
      } else {
        ++nameBuffer[word];
      }

      if(typeof(categoryBuffer[split[2]]) === 'undefined') {
        categoryBuffer[split[2]] = 1;
      } else {
        ++categoryBuffer[split[2]];
      }
    }
  };

  const ret: Buffer[] = [];
  const ret2: Buffer[] = [];

  for(const name in categoryBuffer) {
    ret2.push({ name, count: categoryBuffer[name] });
  }

  console.log('GENERAL CATEGORIES\n');

  for(const entry of ret2.sort(compareFn)) {
    console.log(`${entry.count} :: ${entry.name}`);
  }

  console.log('\nWORDS\n');

  for(const name in nameBuffer) {
    ret.push({ name, count: nameBuffer[name] });
  }

  for(const entry of ret.sort(compareFn)) {
    console.log(`${entry.count} :: ${entry.name}`);
  }

  console.log('\nNUMBERS\n');

  const numbersBuffer: Numeric[] = [];

  for(const name in hasNumber) {
    const values = name.split('/'); // Check if it's a fraction
    const value = values.length === 1 ? parseFloat(values[0]) :
      Math.floor((parseFloat(values[0]) / parseFloat(values[1])) * 100) / 100;
    const count = hasNumber[name];

    numbersBuffer.push({ name, value, count });
  }

  numbersBuffer.sort((a: Numeric, b: Numeric) => b.count - a.count);

  for(const num of numbersBuffer) {
    console.log(`${num.name} (${num.value}): ${num.count}`);
  }

  console.log('\nCOUNT\n');
  console.log(`${wordsCount.toLocaleString()} words (${(wordsCount * 5).toLocaleString()} bytes)`);
  console.log(`${charsCount.toLocaleString()} characters (${(charsCount).toLocaleString()} bytes)`);

  const fheader = `${header('unicode_data')}

#include "ucx.h"

#define UCX_CHARACTER_MAX ${lines}

extern ucx_character ucx_characters[UCX_CHARACTER_MAX];

${footer('unicode_data')}
`;

  const ffile = `${license()}

#include "unicode_data.h"

ucx_character ucx_characters[] = {
${entries.join(',\n')}
};\n`;

  writeFileSync('../src/unicode_data.h', fheader);
  writeFileSync('../src/unicode_data.c', ffile);
}

async function readBlocks() {
  const macros: string[] = [];
  const entries: string[] = [];

  const rl = createInterface({
    input: createReadStream('./UCD/Blocks.txt'),
    crlfDelay: Infinity
  });

  for await (const line of rl) {
    if(line.startsWith('#') || line === '') { // Comment
      continue;
    }

    const split = line.split('; ');
    const blockName = split[1].toUpperCase().replace(/[ \-]/g, '_');
    const value = split[0].split('..')[0];

    macros.push(`#define UCX_BLOCK_${blockName} 0x${value}`);
    entries.push(`    "${split[1]}"`);
  }

  const fheader = `${header('blocks')}

${macros.join('\n')}

#define UCX_BLOCK_NUM ${macros.length}

extern const char* ucx_blocks[UCX_BLOCK_NUM];

${footer('blocks')}
`;

  const ffile = `${license()}

const char* ucx_blocks[] = {
${entries.join(',\n')}
};
`;

  writeFileSync('../src/blocks.h', fheader);
  writeFileSync('../src/blocks.c', ffile);
}

readUnicodeData();
readBlocks();
