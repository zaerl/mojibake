import { writeFileSync, createReadStream } from 'fs';
import { createInterface } from 'readline';

interface Buffer {
  name: string;
  count: number;
}

interface Numeric {
  name: string;
  value: number;
  count: number;
}

function compareFn(a: Buffer, b: Buffer): number {
  const ret = b.count - a.count;

  if(ret === 0) {
    if(a.name < b.name) {
      return -1;
    } else if(a.name > b.name) {
      return 1;
    }

    return 0;
  }

  return ret;
}

function header(name: string): string {
  name = name.toUpperCase();

  return `${license()}

#ifndef MB_${name}_H
#define MB_${name}_H`;
}

function footer(name: string): string {
  name = name.toUpperCase();

  return `#endif /* MB_${name}_H */`;
}

function license(): string {
  return `/**
 * The mojibake library
 *
 * This file is distributed under the MIT License. See LICENSE for details.
 *
 * This code is autogenerated do not modify
 */`;
}

async function readUnicodeData() {
  const nameBuffer: { [name: string]: number } = {};
  const categoryBuffer: { [name: string]: number } = {};
  let charsCount = 0;
  let wordsCount = 0;
  let lines = 0;
  let entries: string[] = [];
  let hasNumber: { [name: string]: number } = {};
  let previousCodepoint = 0;

  const rl = createInterface({
    input: createReadStream('./UCD/UnicodeData.txt'),
    crlfDelay: Infinity
  });

  for await (const line of rl) {
    const split = line.split(';');
    const name = split[2] === 'Cc' && split[10] !== '' ? split[10] : split[1];
    const words = name.split(' ');
    const codepoint = parseInt(split[0], 16);

    if(codepoint - previousCodepoint > 1) {
      console.log(`STEP (${codepoint} -- ${codepoint - previousCodepoint})`);
    }

    previousCodepoint = codepoint;
    ++lines;
    charsCount += name.length;
    wordsCount += words.length;

    if(split[8] !== '') {
      if(typeof(hasNumber[split[8]]) === 'undefined') {
        hasNumber[split[8]] = 1;
      } else {
        ++hasNumber[split[8]];
      }
    }

    entries.push(`    { 0x${split[0]}, MB_GENERAL_CATEGORY_${split[2].toUpperCase()}, "${name}" }`);

    for(const word of words) {
      if(typeof(nameBuffer[word]) === 'undefined') {
        nameBuffer[word] = 1;
      } else {
        ++nameBuffer[word];
      }

      if(typeof(categoryBuffer[split[2]]) === 'undefined') {
        categoryBuffer[split[2]] = 1;
      } else {
        ++categoryBuffer[split[2]];
      }
    }
  };

  const ret: Buffer[] = [];
  const ret2: Buffer[] = [];

  for(const name in categoryBuffer) {
    ret2.push({ name, count: categoryBuffer[name] });
  }

  console.log('GENERAL CATEGORIES\n');

  ret2.sort(compareFn);
  let buffer: string[] = [];
  let prevCount = ret2[0].count;

  for(const entry of ret2) {
    buffer.push(entry.name);

    if(entry.count !== prevCount) {
      console.log(`${entry.count} :: ${buffer.join(', ')}`);

      prevCount = entry.count;
      buffer = [];
    }
  }

  console.log('\nWORDS\n');

  for(const name in nameBuffer) {
    ret.push({ name, count: nameBuffer[name] });
  }

  ret.sort(compareFn);
  buffer = [];
  prevCount = ret[0].count;

  for(const entry of ret.sort(compareFn)) {
    buffer.push(entry.name);

    if(entry.count !== prevCount) {
      console.log(`${entry.count} :: ${buffer.join(', ')}`);

      prevCount = entry.count;
      buffer = [];
    }
  }

  console.log('\nNUMBERS\n');

  const numbersBuffer: Numeric[] = [];

  for(const name in hasNumber) {
    const values = name.split('/'); // Check if it's a fraction
    const value = values.length === 1 ? parseFloat(values[0]) :
      Math.floor((parseFloat(values[0]) / parseFloat(values[1])) * 100) / 100;
    const count = hasNumber[name];

    numbersBuffer.push({ name, value, count });
  }

  numbersBuffer.sort((a: Numeric, b: Numeric) => b.count - a.count);

  for(const num of numbersBuffer) {
    console.log(`${num.name} (${num.value}): ${num.count}`);
  }

  console.log('\nCOUNT\n');
  console.log(`${wordsCount.toLocaleString()} words (${(wordsCount * 5).toLocaleString()} bytes)`);
  console.log(`${charsCount.toLocaleString()} characters (${(charsCount).toLocaleString()} bytes)`);

  const fheader = `${header('unicode_data')}

#include "mb.h"

#define MB_CHARACTER_MAX ${lines}

extern mb_character mb_characters[MB_CHARACTER_MAX];

${footer('unicode_data')}
`;

  const ffile = `${license()}

#include "unicode_data.h"

mb_character mb_characters[] = {
${entries.join(',\n')}
};\n`;

  writeFileSync('../src/unicode_data.h', fheader);
  writeFileSync('../src/unicode_data.c', ffile);
}

async function readBlocks() {
  const macros: string[] = [];
  const entries: string[] = [];

  const rl = createInterface({
    input: createReadStream('./UCD/Blocks.txt'),
    crlfDelay: Infinity
  });

  let i = 0;

  for await (const line of rl) {
    if(line.startsWith('#') || line === '') { // Comment
      continue;
    }

    const split = line.split('; ');
    const blockName = split[1].toUpperCase().replace(/[ \-]/g, '_');
    const values = split[0].split('..');
    const size = parseInt(values[1], 16) - parseInt(values[0], 16);

    macros.push(`#define MB_BLOCK_${blockName} ${i++}`);
    entries.push(`    { 0x${values[0]}, ${size}, "${split[1]}" }`);
  }

  const fheader = `${header('blocks')}

#include "mb.h"

#define MB_BLOCK_NUM ${macros.length}

${macros.join('\n')}

extern mb_block mb_blocks[MB_BLOCK_NUM];

${footer('blocks')}
`;

  const ffile = `${license()}

#include "blocks.h"

mb_block mb_blocks[] = {
${entries.join(',\n')}
};
`;

  writeFileSync('../src/blocks.h', fheader);
  writeFileSync('../src/blocks.c', ffile);
}

readUnicodeData();
readBlocks();
