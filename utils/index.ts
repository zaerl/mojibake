import { createReadStream, writeFileSync, unlinkSync } from 'fs';
import { createInterface } from 'readline';
import { verbose, Statement } from 'sqlite3';

interface Buffer {
  name: string;
  count: number;
}

interface Numeric {
  name: string;
  value: number;
  count: number;
}

enum GeneralCategory {
  Lu,
  Ll,
  Lt,
  Lm,
  Lo,
  Mn,
  Mc,
  Me,
  Nd,
  Nl,
  No,
  Pc,
  Pd,
  Ps,
  Pe,
  Pi,
  Pf,
  Po,
  Sm,
  Sc,
  Sk,
  So,
  Zs,
  Zl,
  Zp,
  Cc,
  Cf,
  Cs,
  Co,
  Cn,
};

type GeneralCategoriesStrings = keyof typeof GeneralCategory;

enum BidirectionalCategories {
  L,
  LRE,
  LRO,
  R,
  AL,
  RLE,
  RLO,
  PDF,
  EN,
  ES,
  ET,
  AN,
  CS,
  NSM,
  BN,
  B,
  S,
  WS,
  ON
};

type BidirectionalCategoriesStrings = (keyof typeof BidirectionalCategories) | '';

enum CharacterDecompositionMapping {
  '<font>',
  '<noBreak>',
  '<initial>',
  '<medial>',
  '<final>',
  '<isolated>',
  '<circle>',
  '<super>',
  '<sub>',
  '<vertical>',
  '<wide>',
  '<narrow>',
  '<small>',
  '<square>',
  '<fraction>',
  '<compat>'
};

type CharacterDecompositionMappingStrings = (keyof typeof CharacterDecompositionMapping) | '';

type CharacterDecomposition = [
  CharacterDecompositionMappingStrings,
  ...string[]
];

type Mirrored = 'Y' | 'N';

type UnicodeDataRow = [
  string, // codepoint
  string, // character name
  GeneralCategoriesStrings, // general category
  string, // canonical combining classes
  BidirectionalCategoriesStrings, // bidirectional category
  string, // character decomposition mapping
  string, // decimal digit value
  string, // digit value
  string, // numeric value
  Mirrored, // mirrored
  string, // unicode 1.0 name
  string, // 10646 comment field
  string, // uppercase mapping
  string, // lowercase mapping
  string // titlecase mapping
];

function compareFn(a: Buffer, b: Buffer): number {
  const ret = b.count - a.count;

  if(ret === 0) {
    if(a.name < b.name) {
      return -1;
    } else if(a.name > b.name) {
      return 1;
    }

    return 0;
  }

  return ret;
}

function header(name: string): string {
  name = name.toUpperCase();

  return `${license()}

#ifndef MB_${name}_H
#define MB_${name}_H`;
}

function footer(name: string): string {
  name = name.toUpperCase();

  return `#endif /* MB_${name}_H */`;
}

function license(): string {
  return `/**
 * The mojibake library
 *
 * This file is distributed under the MIT License. See LICENSE for details.
 *
 * This code is autogenerated do not modify
 */`;
}

async function readUnicodeData(stmt: Statement) {
  console.log('READ UNICODE DATA');

  const nameBuffer: { [name: string]: number } = {};
  const categoryBuffer: { [name: string]: number } = {};
  let charsCount = 0;
  let wordsCount = 0;
  let lines = 0;
  let entries: string[] = [];
  let hasNumber: { [name: string]: number } = {};
  let previousCodepoint = 0;
  let diffs = 0;
  let codepoint = 0;

  const rl = createInterface({
    input: createReadStream('./UCD/UnicodeData.txt'),
    crlfDelay: Infinity
  });

  for await (const line of rl) {
    const split = line.split(';') as UnicodeDataRow;
    const name = split[2] === 'Cc' && split[10] !== '' ? split[10] : split[1];
    const words = name.split(' ');
    codepoint = parseInt(split[0], 16);
    const diff = codepoint - previousCodepoint;

    if(diff > 1) {
      diffs += diff;
      console.log(`STEP (${split[0]} -- ${codepoint - previousCodepoint})`);
    }

    previousCodepoint = codepoint;
    ++lines;
    charsCount += name.length;
    wordsCount += words.length;

    if(split[8] !== '') {
      if(typeof(hasNumber[split[8]]) === 'undefined') {
        hasNumber[split[8]] = 1;
      } else {
        ++hasNumber[split[8]];
      }
    }

    entries.push(`    { 0x${split[0]}, MB_GENERAL_CATEGORY_${split[2].toUpperCase()}, "${name}" }`);

    const decomposition = split[5].split(' ') as CharacterDecomposition;

    stmt.run(
      codepoint,
      name,
      0, // Block
      GeneralCategory[split[2]],
      split[3],
      split[4] === '' ? null : BidirectionalCategories[split[4]],
      decomposition[0] === '' ? null : CharacterDecompositionMapping[decomposition[0]],
      split[6] === '' ? null : split[6],
      split[7] === '' ? null : split[7],
      split[8] === 'Y' ? 1 : 0,
      // unicode 1.0 name
      // 10646 comment field
      split[11] === '' ? null : split[11],
      split[12] === '' ? null : split[12],
      split[13] === '' ? null : split[13]
    );

    for(const word of words) {
      if(typeof(nameBuffer[word]) === 'undefined') {
        nameBuffer[word] = 1;
      } else {
        ++nameBuffer[word];
      }

      if(typeof(categoryBuffer[split[2]]) === 'undefined') {
        categoryBuffer[split[2]] = 1;
      } else {
        ++categoryBuffer[split[2]];
      }
    }
  };

  stmt.finalize();

  console.log(`STEP TOTAL ${diffs}/${codepoint}\n`);

  const ret: Buffer[] = [];
  const ret2: Buffer[] = [];

  for(const name in categoryBuffer) {
    ret2.push({ name, count: categoryBuffer[name] });
  }

  console.log('GENERAL CATEGORIES\n');

  ret2.sort(compareFn);
  let buffer: string[] = [];
  let prevCount = ret2[0].count;

  for(const entry of ret2) {
    buffer.push(entry.name);

    if(entry.count !== prevCount) {
      console.log(`${entry.count} :: ${buffer.join(', ')}`);

      prevCount = entry.count;
      buffer = [];
    }
  }

  console.log('\nWORDS\n');

  for(const name in nameBuffer) {
    ret.push({ name, count: nameBuffer[name] });
  }

  ret.sort(compareFn);
  buffer = [];
  prevCount = ret[0].count;

  for(const entry of ret) {
    buffer.push(entry.name);

    if(entry.count !== prevCount) {
      const line = buffer.length > 10 ? buffer.slice(0, 10).join(', ') + '...' : buffer.join(', ');

      console.log(`${entry.count} :: ${line}`);

      prevCount = entry.count;
      buffer = [];
    }
  }

  console.log('\nNUMBERS\n');

  const numbersBuffer: Numeric[] = [];

  for(const name in hasNumber) {
    const values = name.split('/'); // Check if it's a fraction
    const value = values.length === 1 ? parseFloat(values[0]) :
      Math.floor((parseFloat(values[0]) / parseFloat(values[1])) * 100) / 100;
    const count = hasNumber[name];

    numbersBuffer.push({ name, value, count });
  }

  numbersBuffer.sort((a: Numeric, b: Numeric) => b.count - a.count);

  for(const num of numbersBuffer) {
    console.log(`${num.name} (${num.value}): ${num.count}`);
  }

  console.log('\nCOUNT\n');
  console.log(`${wordsCount.toLocaleString()} words (${(wordsCount * 5).toLocaleString()} bytes)`);
  console.log(`${charsCount.toLocaleString()} characters (${(charsCount).toLocaleString()} bytes)`);

  const fheader = `${header('unicode_data')}

#include "mojibake.h"

#define MB_CHARACTER_MAX ${lines}

extern mb_character mb_characters[MB_CHARACTER_MAX];

${footer('unicode_data')}
`;

  const ffile = `${license()}

#include "unicode_data.h"

mb_character mb_characters[] = {
${entries.join(',\n')}
};\n`;

  writeFileSync('../src/unicode_data.h', fheader);
  writeFileSync('../src/unicode_data.c', ffile);
}

async function readBlocks(stmt: Statement) {
  console.log('READ BLOCKS');

  const macros: string[] = [];
  const entries: string[] = [];

  const rl = createInterface({
    input: createReadStream('./UCD/Blocks.txt'),
    crlfDelay: Infinity
  });

  let i = 0;

  for await (const line of rl) {
    if(line.startsWith('#') || line === '') { // Comment
      continue;
    }

    const split = line.split('; ');
    const blockName = split[1].toUpperCase().replace(/[ \-]/g, '_');
    const values = split[0].split('..');
    const size = parseInt(values[1], 16) - parseInt(values[0], 16);

    macros.push(`#define MB_BLOCK_${blockName} ${i++}`);
    entries.push(`    { 0x${values[0]}, ${size}, "${split[1]}" }`);
  }

  const fheader = `${header('blocks')}

#include "mojibake.h"

#define MB_BLOCK_NUM ${macros.length}

${macros.join('\n')}

extern mb_block mb_blocks[MB_BLOCK_NUM];

${footer('blocks')}
`;

  const ffile = `${license()}

#include "blocks.h"

mb_block mb_blocks[] = {
${entries.join(',\n')}
};
`;

  writeFileSync('../src/blocks.h', fheader);
  writeFileSync('../src/blocks.c', ffile);
}

// Remove old database
unlinkSync('./out.db');

const sqlite = verbose();
const db = new sqlite.Database('./out.db', (err: Error | null) => {
  console.error(err?.message);
});

db.serialize(async () => {

  db.run('BEGIN TRANSACTION');

  db.run(
`CREATE TABLE data(
  codepoint INTEGER NOT NULL PRIMARY KEY,
  name TEXT NOT NULL,
  block INTEGER NOT NULL,
  category INTEGER NOT NULL,
  combining TEXT,
  bidirectional INTEGER,
  decomposition INTEGER,
  decimal TEXT,
  digit TEXT,
  numeric TEXT,
  mirrored INTEGER,
  uc TEXT,
  lc TEXT,
  tc TEXT
) WITHOUT ROWID`);

  const stmt = db.prepare('INSERT INTO data VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)');

  await readUnicodeData(stmt);
  await readBlocks(stmt);

  db.run('END');

  db.close();
});
